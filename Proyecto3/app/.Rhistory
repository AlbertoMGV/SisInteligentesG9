# This function must return a list with the information needed to
# solve the problem.
# (Depending on the problem, it should receive or not parameters)
initialize.problem = function(){
problem = list()
# problem$state.initial = <Insert code here>
# problem$state.final   = <Insert code here or remove line if not needed>
# problem$actions.possible = <Insert code here>
# problem$name = <Insert code here>
# problem$<aditional info> = <Insert code here>
return(problem)
}
# =======================================================================
# Must return TRUE or FALSE according with if the action can be done or not
# over the specific state
is.applicable = function (state,action,problem){
result = FALSE
# <insert code here in order to calculate result value>
return(result)
}
# =======================================================================
# Must return the state resulting on applying the action over the state
effect = function (state,action){
result = state
# <insert code here in order to modify the resulting state>
return(result)
}
# =======================================================================
# Must return TRUE or FALSE according with the state is final or not
# * In case the final state is stablished by a condition, second argument
#   could be omited
is.final.state = function (state, finalstate=NULL){
result = TRUE
# <insert code here in order to modify the resulting state>
return(result)
}
# =======================================================================
# Must print the state in console (in a legible way)
to.string = function (state){
# <insert code here to print the state>
}
# =======================================================================
# Return the cost of applying an action over a state
get.cost = function (action,state){
# Return the cost of applying an action over a state
return(1)
}
# =======================================================================
# (Used for Informed Algorithms)
# Heuristic function used in Informed algorithms
get.evaluation = function(state,problem){
return(1)
}
View(get.evaluation)
View(effect)
library(shiny)
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Old Faithful Geyser Data"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
)
# Define server logic required to draw a histogram
server <- function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
}
# Run the application
shinyApp(ui = ui, server = server)
# =======================================================================
# Names: Alberto Miranda & Danel Lorente
# Group Number:
# Assignment: Sistemas Inteligentes
# Date: 23/04/2019
# =======================================================================
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(RKEEL)
library(caret)
library(ggplot2)
library(lattice)
data = read.keel("../data/baseball.dat")
# Split the data into training and test set
folds <- createMultiFolds(y=data$Salary,k = 5, times = 1)
print(folds)
for(i in 1:5){
#Segement your data by fold using the which() function
train.data  <- data[folds[[i]], ]
test.data <- data[-folds[[i]], ]
#Use the test and train data partitions however you desire...
linear.model <- lm(Salary~., train.data)
prediction <- predict(linear.model, test.data)
abs(prediction - test.data$Salary)
data.frame( R2 = R2(prediction, test.data$Salary),
RMSE = RMSE(prediction, test.data$Salary),
MAE = MAE(prediction, test.data$Salary))
# Define training control
train.control <- trainControl(method = "cv", number = 5)
# Train the model
model <- train(Salary~., data, method = "lm",
trControl = train.control)
print(model)
}
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
install.packages(c("RKEEL", "lattice", "ggplot2", "caret"))
# =======================================================================
# Names: Alberto Miranda & Danel Lorente
# Group Number:
# Assignment: Sistemas Inteligentes
# Date: 23/04/2019
# =======================================================================
rm(list=ls())
cat("\014")
graphics.off()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
dir()
# LIBRARIES (add any needed library here)
library(RKEEL)
library(caret)
library(ggplot2)
library(lattice)
data = read.keel("../data/baseball.dat")
# Split the data into training and test set
folds <- createMultiFolds(y=data$Salary,k = 5, times = 1)
print(folds)
for(i in 1:5){
#Segement your data by fold using the which() function
train.data  <- data[folds[[i]], ]
test.data <- data[-folds[[i]], ]
#Use the test and train data partitions however you desire...
linear.model <- lm(Salary~., train.data)
prediction <- predict(linear.model, test.data)
abs(prediction - test.data$Salary)
data.frame( R2 = R2(prediction, test.data$Salary),
RMSE = RMSE(prediction, test.data$Salary),
MAE = MAE(prediction, test.data$Salary))
# Define training control
train.control <- trainControl(method = "cv", number = 5)
# Train the model
model <- train(Salary~., data, method = "lm",
trControl = train.control)
print(model)
}
detach("package:ggplot2", unload=TRUE)
library("ggplot2", lib.loc="D:/Archivos de programa/R/R-3.5.2/library")
detach("package:ggplot2", unload=TRUE)
remove.packages("ggplot2")
remove.packages("RKEEL")
remove.packages("RKEELdata")
remove.packages("RKEELjars")
